<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Z-Up Particle System</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; color: white; font-family: 'Segoe UI', sans-serif; }
        #canvas-container { width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; z-index: 1; }
        #video-input { position: absolute; top: 10px; left: 10px; width: 160px; height: 120px; z-index: 2; transform: scaleX(-1); border: 1px solid #444; border-radius: 8px; opacity: 0.6; }
        #loading { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); z-index: 10; font-size: 18px; color: #aaa; pointer-events: none; text-align: center; }
        .instruction { position: absolute; bottom: 30px; left: 30px; z-index: 2; background: rgba(20, 20, 20, 0.8); padding: 15px; border-radius: 12px; border: 1px solid #333; pointer-events: none; backdrop-filter: blur(5px);}
        h3 { margin: 0 0 10px 0; font-size: 16px; color: #fff; }
        p { margin: 5px 0; font-size: 13px; color: #ccc; }
    </style>
    <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@0.150.1/build/three.module.js",
          "three/addons/": "https://unpkg.com/three@0.150.1/examples/jsm/"
        }
      }
    </script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="loading">
        <div style="margin-bottom: 10px;">‚ú®</div>
        Initializing Z-Up Coordinate System...
    </div>
    <video id="video-input"></video>
    <div id="canvas-container"></div>
    <div class="instruction">
        <h3>üñê Interaction Guide</h3>
        <p>1. <b>Open Hand</b>: Particles Explode</p>
        <p>2. <b>Close Hand</b>: Particles Contract</p>
        <p>3. <b>Note</b>: Z-Axis is now VERTICAL (Up)</p>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { GUI } from 'three/addons/libs/lil-gui.module.min.js';

        // --- Configuration ---
        const PARTICLE_COUNT = 20000; 
        const PARTICLE_SIZE = 0.05;
        
        let scene, camera, renderer, particleSystem, geometry, material;
        let positions, targetPositions;
        let currentShape = 'heart';
        let handInfluence = 0; 
        let gestureState = 'neutral';
        let clock = new THREE.Clock();
        
        const params = {
            color: '#ff0055',
            shape: 'heart',
            size: PARTICLE_SIZE,
            speed: 0.06
        };

        initThree();
        initParticles();
        initGUI();
        initMediaPipe();
        animate();

        function initThree() {
            const container = document.getElementById('canvas-container');
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x050505, 0.02);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            
            // --- CRITICAL FIX: Z-UP SYSTEM ---
            camera.up.set(0, 0, 1); // Sets Z as the vertical axis
            camera.position.set(0, -8, 4); // Move back in Y, up in Z to look down
            camera.lookAt(0, 0, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); 
            container.appendChild(renderer.domElement);

            const controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.autoRotate = false; // We handle rotation manually
        }

        function initParticles() {
            geometry = new THREE.BufferGeometry();
            positions = new Float32Array(PARTICLE_COUNT * 3);
            targetPositions = new Float32Array(PARTICLE_COUNT * 3);

            for (let i = 0; i < PARTICLE_COUNT * 3; i++) {
                positions[i] = (Math.random() - 0.5) * 15;
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            const sprite = new THREE.TextureLoader().load('https://threejs.org/examples/textures/sprites/spark1.png');

            material = new THREE.PointsMaterial({
                color: params.color,
                size: params.size,
                map: sprite,
                transparent: true,
                opacity: 0.8,
                blending: THREE.AdditiveBlending,
                depthWrite: false,
                sizeAttenuation: true
            });

            particleSystem = new THREE.Points(geometry, material);
            scene.add(particleSystem);

            calculateTargetPositions('heart');
        }

        // --- MATH REWRITTEN FOR Z-UP (Z is Height) ---
        function calculateTargetPositions(shape) {
            const positions = new Float32Array(PARTICLE_COUNT * 3);
            
            // Helper: x, y, z (z is height)
            function setPos(i, x, y, z) {
                positions[i*3] = x;
                positions[i*3+1] = y;
                positions[i*3+2] = z;
            }

            let idx = 0;

            if (shape === 'heart') {
                // Heart: Standing upright on Z-axis
                while (idx < PARTICLE_COUNT) {
                    const x = (Math.random() - 0.5) * 3; // Width
                    const z = (Math.random() - 0.5) * 3; // Height (was y)
                    const y = (Math.random() - 0.5) * 3; // Depth
                    
                    const xx = x * 1.1; 
                    const zz = z * 1.1; // Height in math formula
                    const yy = y * 1.1;

                    // Heart formula (using z as "up" variable in the equation context)
                    // (x^2 + 9/4z^2 + y^2 - 1)^3... 
                    // Note: Usually heart is plotted on XY. Let's make it stand up.
                    // We swap Y and Z in the standard formula.
                    
                    const a = xx*xx + (9/4)*zz*zz + yy*yy - 1;
                    
                    if (a*a*a - xx*xx*yy*yy*yy - (9/80)*zz*zz*yy*yy*yy < 0) {
                         // Swap Y and Z for visual verticality
                         // x = Left/Right
                         // y = Depth
                         // z = Up
                        setPos(idx, x * 1.5, y * 0.5, z * 1.5 + 0.5); 
                        idx++;
                    }
                }

            } else if (shape === 'flower') {
                // Flower: Laying flat on XY plane, petals growing up in Z
                const scale = 2;
                for (let i = 0; i < PARTICLE_COUNT; i++) {
                    if (i < PARTICLE_COUNT * 0.15) {
                        // Center
                        const r = Math.random() * 0.5;
                        const theta = Math.random() * Math.PI * 2;
                        const phi = Math.acos(2 * Math.random() - 1);
                        setPos(i, r*Math.sin(phi)*Math.cos(theta), r*Math.sin(phi)*Math.sin(theta), r*Math.cos(phi));
                    } else {
                        const t = i / (PARTICLE_COUNT * 0.85);
                        const theta = i * 2.39996;
                        const r = Math.sqrt(t) * scale;
                        const wave = Math.sin(theta * 7); 
                        
                        // Z is height
                        let z = (r * r) * 0.3 + wave * 0.2 * r; 

                        const x = r * Math.cos(theta);
                        const y = r * Math.sin(theta);
                        
                        setPos(i, x, y, z - 1); 
                    }
                }

            } else if (shape === 'solar') {
                // Solar System: Orbits on XY Plane
                const sunCount = 2000;
                const planetCounts = 300; 
                const orbitCount = PARTICLE_COUNT - sunCount - (8 * planetCounts); 

                // Sun (Sphere)
                for (let j = 0; j < sunCount; j++) {
                    const r = Math.random() * 0.8;
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.acos(2 * Math.random() - 1);
                    setPos(idx++, r*Math.sin(phi)*Math.cos(theta), r*Math.sin(phi)*Math.sin(theta), r*Math.cos(phi));
                }

                const radii = [1.2, 1.8, 2.5, 3.5, 5.5, 7.5, 9.5, 11.0];

                for (let p = 0; p < 8; p++) {
                    const r = radii[p];
                    
                    // Orbits (Flat on XY)
                    const ringParticles = Math.floor(orbitCount / 8);
                    for(let k=0; k<ringParticles; k++){
                        const angle = Math.random() * Math.PI * 2;
                        const radiusVar = r + (Math.random()-0.5) * 0.1;
                        // Z is 0 (flat)
                        setPos(idx++, radiusVar * Math.cos(angle), radiusVar * Math.sin(angle), (Math.random()-0.5)*0.05);
                    }

                    // Planets
                    const planetAngle = Math.random() * Math.PI * 2;
                    const px = r * Math.cos(planetAngle);
                    const py = r * Math.sin(planetAngle);
                    
                    for(let k=0; k<planetCounts; k++){
                        let pSize = (p === 4 || p === 5) ? 0.35 : 0.15;
                        const pr = Math.random() * pSize;
                        const pt = Math.random() * Math.PI * 2;
                        const pp = Math.acos(2 * Math.random() - 1);
                        
                        setPos(idx++, 
                            px + pr*Math.sin(pp)*Math.cos(pt), 
                            py + pr*Math.sin(pp)*Math.sin(pt), 
                            pr*Math.cos(pp) // Z offset
                        );
                    }
                }
                while(idx < PARTICLE_COUNT) setPos(idx++, 0,0,0);

            } else if (shape === 'saturn') {
                // Saturn: Tilted 45 degrees relative to Z-up
                const coreParticles = Math.floor(PARTICLE_COUNT * 0.4);
                const ringParticles = PARTICLE_COUNT - coreParticles;
                const tiltAngle = Math.PI / 4; // 45 degrees

                // Core
                for (let i = 0; i < coreParticles; i++) {
                    const r = Math.random() * 1.5;
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.acos(2 * Math.random() - 1);
                    setPos(idx++, r * Math.sin(phi) * Math.cos(theta), r * Math.sin(phi) * Math.sin(theta), r * Math.cos(phi));
                }

                // Ring
                for (let i = 0; i < ringParticles; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const r = 2.5 + Math.random() * 2.0;
                    
                    // Start flat on XY
                    let x = r * Math.cos(angle);
                    let y = r * Math.sin(angle);
                    let z = (Math.random() - 0.5) * 0.1;

                    // Rotate around X axis to tilt 45 degrees
                    const ty = y * Math.cos(tiltAngle) - z * Math.sin(tiltAngle);
                    const tz = y * Math.sin(tiltAngle) + z * Math.cos(tiltAngle);
                    
                    setPos(idx++, x, ty, tz);
                }

            } else if (shape === 'christmasTree') {
                // Tree: Growing UP along +Z
                const treeHeight = 6;
                const coneLayers = 5;
                const particlesPerLayer = Math.floor(PARTICLE_COUNT * 0.8 / coneLayers);
                const starParticles = Math.floor(PARTICLE_COUNT * 0.05);
                const ornamentParticles = PARTICLE_COUNT - coneLayers * particlesPerLayer - starParticles;

                for (let layer = 0; layer < coneLayers; layer++) {
                    // Z base
                    const zBase = -2 + (layer / coneLayers) * treeHeight * 0.8;
                    const radius = (1 - layer / coneLayers) * 2.5;
                    const height = treeHeight / coneLayers * 1.5;

                    for (let i = 0; i < particlesPerLayer; i++) {
                        const r = Math.sqrt(Math.random()) * radius;
                        const theta = Math.random() * Math.PI * 2;
                        const z = zBase + Math.random() * height * 0.8;

                        setPos(idx++, r * Math.cos(theta), r * Math.sin(theta), z);
                    }
                }

                // Star (Atop Z)
                for (let i = 0; i < starParticles; i++) {
                    const r = Math.random() * 0.4;
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.acos(2 * Math.random() - 1);
                    setPos(idx++, 
                        r * Math.sin(phi) * Math.cos(theta), 
                        r * Math.sin(phi) * Math.sin(theta),
                        3.5 + r * Math.cos(phi) // Top of tree Z=3.5
                    );
                }

                // Ornaments
                for (let i = 0; i < ornamentParticles; i++) {
                    const layer = Math.floor(Math.random() * coneLayers);
                    const zBase = -2 + (layer / coneLayers) * treeHeight * 0.8;
                    const radius = (1 - layer / coneLayers) * 2.5;

                    const r = Math.random() * radius * 0.9; 
                    const theta = Math.random() * Math.PI * 2;
                    const z = zBase + Math.random() * (treeHeight / coneLayers * 1.5);
                    
                    setPos(idx++, r * Math.cos(theta), r * Math.sin(theta), z);
                }

            } else if (shape === 'fireworks') {
                // Fireworks: Shooting UP Z axis
                 const trailCount = 80;
                 const particlesPerTrail = Math.floor(PARTICLE_COUNT / trailCount);
                 
                 for (let t = 0; t < trailCount; t++) {
                     const theta = Math.random() * Math.PI * 2;
                     const phi = Math.acos(2 * Math.random() - 1);
                     
                     const dx = Math.sin(phi) * Math.cos(theta);
                     const dy = Math.sin(phi) * Math.sin(theta);
                     const dz = Math.cos(phi);
 
                     const maxLen = 3 + Math.random() * 3;
 
                     for (let p = 0; p < particlesPerTrail; p++) {
                         const progress = p / particlesPerTrail; 
                         const dist = progress * maxLen;
                         const gravity = progress * progress * -1.5; // Falls down Z
 
                         setPos(idx++, 
                             dx * dist + (Math.random()-0.5)*0.1, 
                             dy * dist + (Math.random()-0.5)*0.1, 
                             dz * dist + gravity + (Math.random()-0.5)*0.1 // Gravity on Z
                         );
                     }
                 }
            }
            
            targetPositions = positions;
        }

        function initGUI() {
            const gui = new GUI();
            gui.title('Control Panel');

            const shapeList = {
                'Heart': 'heart',
                'Flower': 'flower',
                'Solar System': 'solar',
                'Saturn': 'saturn',
                'Fireworks': 'fireworks',
                'Christmas Tree': 'christmasTree'
            };

            gui.add(params, 'shape', shapeList).name('Select Model').onChange(val => {
                currentShape = val;
                calculateTargetPositions(val);
                
                if(val === 'heart') params.color = '#ff0055';
                else if(val === 'solar') params.color = '#ffaa00';
                else if(val === 'saturn') params.color = '#e0c0a0'; 
                else if(val === 'flower') params.color = '#ff66aa';
                else if(val === 'fireworks') params.color = '#ffffff';
                else if(val === 'christmasTree') params.color = '#00ff00';

                material.color.set(params.color);
            });

            gui.addColor(params, 'color').name('Particle Color').onChange(val => {
                material.color.set(val);
            });

            gui.add(params, 'size', 0.01, 0.2).name('Particle Size').onChange(val => {
                material.size = val;
            });
        }

        function initMediaPipe() {
            const videoElement = document.getElementById('video-input');
            const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
            
            hands.setOptions({
                maxNumHands: 1,
                modelComplexity: 1,
                minDetectionConfidence: 0.5,
                minTrackingConfidence: 0.5
            });

            hands.onResults(results => {
                if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                    const lm = results.multiHandLandmarks[0];
                    const d = Math.sqrt(Math.pow(lm[4].x - lm[8].x, 2) + Math.pow(lm[4].y - lm[8].y, 2));
                    gestureState = d < 0.05 ? 'closed' : (d > 0.15 ? 'open' : 'neutral');
                } else {
                    gestureState = 'neutral';
                }
            });

            const cameraUtils = new Camera(videoElement, {
                onFrame: async () => await hands.send({image: videoElement}),
                width: 320, height: 240
            });
            cameraUtils.start().then(() => document.getElementById('loading').style.display = 'none');
        }

        function animate() {
            requestAnimationFrame(animate);
            const time = clock.getElapsedTime();
            
            let targetInfluence = 0;
            if (gestureState === 'open') targetInfluence = 1.0; 
            else if (gestureState === 'closed') targetInfluence = -0.8; 
            
            handInfluence += (targetInfluence - handInfluence) * 0.1;

            const pos = geometry.attributes.position.array;
            
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const ix = i * 3;
                const iy = i * 3 + 1;
                const iz = i * 3 + 2;

                const tx = targetPositions[ix];
                const ty = targetPositions[iy];
                const tz = targetPositions[iz];
                
                let scale = 1 + handInfluence;
                if(scale < 0.1) scale = 0.1;

                const noiseSpeed = 0.5;
                const noiseAmp = 0.03;
                const nx = Math.sin(time * noiseSpeed + ty) * noiseAmp;
                const ny = Math.cos(time * noiseSpeed + tx) * noiseAmp;
                const nz = Math.sin(time * noiseSpeed + tz) * noiseAmp;

                const destX = tx * scale + nx;
                const destY = ty * scale + ny;
                const destZ = tz * scale + nz;

                pos[ix] += (destX - pos[ix]) * params.speed;
                pos[iy] += (destY - pos[iy]) * params.speed;
                pos[iz] += (destZ - pos[iz]) * params.speed;
            }

            geometry.attributes.position.needsUpdate = true;
            
            // --- UNIFIED Z-AXIS ROTATION ---
            // Because we set Z as UP, rotating around Z means spinning like a top.
            if(gestureState === 'neutral') {
                particleSystem.rotation.z += 0.002;
            }

            renderer.render(scene, camera);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
    </script>
</body>
</html>
